/* vim:syntax=cpp:filetype=cpp
*/
/*_____________________________________________________________

Template for an EASEA evolutionary algorithm for easea v1.0.3
_______________________________________________________________*/

\User declarations : // This section is copied on top of the output file
#include <string>
#include <iostream>
#include <fstream>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <stdio.h>
#include <string.h>
#include <algorithm>

#define NB_PAPER 263
#define END_CONF 884          //(3*24*60)/5)

#define START_TIME_291 0
#define START_TIME_292 12
#define START_TIME_294 24
#define START_TIME_295 36

using namespace std;

typedef struct{
  int begin;
  int end;
}Constraint;

typedef struct{
  int paperID;
  string paperTitle;
  int trackID;
  string trackTitle;
  int sessionID;
  string sessionTitle;
  int utc;
  int duration;
  vector<Constraint> constraints;
}Paper;

typedef struct{
  int trackID;
  string trackTitle;
  int sessionID;
  string sessionTitle;
  vector<Paper> papers;
}Session;

typedef struct{
  int trackID;
  string trackTitle;
  vector<Session> sessions;
}Track;

typedef struct{
  int nbPapersEndTooLate;     //papers that end after the 3rd day ends
  int nbPapersOverLapInterSession; //papers that overlap with another one inside session
  int nbPapersOverLapInterTrack; //papers that overlap with another one inside track
  int nbPapersOverLapGeneral; //papers that overlap with another one
  int nbPapersDeadlyOverlap;  //papers that overlap with track 15
  vector<int> nbCassures;     //nombre de cassure pour chaque sessions
}Eval;

ifstream fPaper;
vector<Paper> papers;
vector<Track> tracks;

\end

\User functions:

void displayConstraint(Constraint c){
  cout << c.begin <<  " " << c.end;
}
void displayPaper(Paper p){
  cout << "    Paper : " << p.paperID << " - " << p.paperTitle << endl;
  cout << "      UTC : " << p.utc << " Duration : " << p.duration  << endl;
  cout << "      Constraint : ";
  for (int i=0; i < p.constraints.size(); i++){
    displayConstraint(p.constraints[i]);
    cout << " ; ";
  }
  cout << endl;
}

void displaySession(Session s){
  int i;
  cout << "  Session : " << s.sessionID << " - " << s.sessionTitle << endl;
  for(i = 0; i < s.papers.size(); i++)
  {
    displayPaper(s.papers[i]);
  }
}

void displayTrack(Track t){
  cout << "Track : " << t.trackID << " - " << t.trackTitle << endl;
  for (int i = 0; i < t.sessions.size(); i++){
    displaySession(t.sessions[i]);
  }
}

void displayAllTracks() {
  for (int i = 0; i < tracks.size(); i++){
    displayTrack(tracks[i]);
  }
}

string my_strtok(string str, const char sep, size_t& lastSep){
  size_t nextSep = str.find_first_of(sep, lastSep);
  string res = str.substr(lastSep, (nextSep - lastSep));
  lastSep = nextSep + 1;
  return res;
}

// Find an exisitng track or create it and return it
Track& getTrack(int trackID, string trackTitle){
  for (int i=0; i < tracks.size(); ++i){
    if (tracks[i].trackID == trackID){
      return tracks[i];
    }
  }
  Track t;
  t.trackID = trackID;
  t.trackTitle = trackTitle;
  tracks.push_back(t);
  return tracks.back();
}

// Find an existing session in the track or create it an return it
Session& getSessionInTrack(Track& track, int sessionID, string sessionTitle){
  for (int i=0; i < track.sessions.size(); i++){
    if (track.sessions[i].sessionID == sessionID){
      return track.sessions[i];
    }
  }
  Session s;
  s.sessionID = sessionID;
  s.sessionTitle = sessionTitle;
  s.trackID = track.trackID;
  s.trackTitle = track.trackTitle;
  track.sessions.push_back(s);
  return track.sessions.back();
}

int paperTypeToDuration(string paperType){
  if (paperType == "Short paper")
    return 3;
  if (paperType == "Invited talk")
    return 3;
  if (paperType == "Full paper")
    return 6;
  if (paperType == "New Result invited paper")
    return 6;
  if (paperType == "Advanced Introduction invited talk")
    return 6;
  if (paperType == "Poster")
    return 1;
  else
    return 2; // This is the default value, cause why not
}

//Read Papers File
//PaperID | PaperTitle | TrackID | TrackTitle | SessionID | SessionTitle | paperType | utc | TimeConstraint Day 1 | TimeConstraint Day 2 | TimeConstraint Day 3
void readPapersFile(){
  fPaper.open("papers.csv", ios::in);
  const char sep = '%';
  string line;
  if (fPaper.is_open()) {
    while ( getline (fPaper,line) ) {
      Paper p;
      string token;
      char * tokenStart, * tokenEnd;
      string paperType;
      size_t lastSep = 0;
      token = my_strtok(line, sep, lastSep); p.paperID = atoi(token.c_str());
      token = my_strtok(line, sep, lastSep); p.paperTitle = token;
      token = my_strtok(line, sep, lastSep); p.trackID = atoi(token.c_str());
      token = my_strtok(line, sep, lastSep); p.trackTitle = token;
      token = my_strtok(line, sep, lastSep); p.sessionID = atoi(token.c_str());
      token = my_strtok(line, sep, lastSep); p.sessionTitle = token;
      token = my_strtok(line, sep, lastSep);
      p.duration = paperTypeToDuration(token);
      token = my_strtok(line, sep, lastSep); p.utc = atoi(token.c_str())*12;

      for (int day=0; day < 3; day++){
        string dayConstraint = my_strtok(line, sep, lastSep);
        if (dayConstraint.length() != 0){
          char * dstr = new char [dayConstraint.length()+1];
          strcpy(dstr, dayConstraint.c_str());
          tokenStart = strtok(dstr, ",[]"); tokenEnd = strtok(NULL, ",[]");
          while (tokenStart != NULL && tokenEnd != NULL){
            Constraint c;
            c.begin = atoi(tokenStart)*12+p.utc+day*12*24;
            c.end  = atoi(tokenEnd)*12+p.utc+day*12*24;
            p.constraints.push_back(c);
            tokenStart = strtok(NULL, ",[]"); tokenEnd = strtok(NULL, ",[]");
          }
        }
      }

      papers.push_back(p);

      Track& t = getTrack(p.trackID, p.trackTitle);
      Session& s = getSessionInTrack(t, p.sessionID, p.sessionTitle);
      s.papers.push_back(p);
    }
    fPaper.close();
  }
}

Eval getEval( IndividualImpl Genome )
{
  Eval res;
  res.nbPapersEndTooLate = 0;
  res.nbPapersOverLapInterSession = 0;
  res.nbPapersOverLapInterTrack = 0;
  res.nbPapersOverLapGeneral = 0;
  res.nbPapersDeadlyOverlap = 0;

  for(int i = 0; i < NB_PAPER; i++){
    //dealing with ith paper
    if(Genome.planning[i]->startTime + papers[i].duration > END_CONF){
      res.nbPapersEndTooLate++;
    }
  }
  return res;
}

\end

\User CUDA:
//Transfert some variables to GPU here (cudaMalloc, MemCpy)
\end

\User classes :
Creneau {
  int paperID;
  int sessionID;
  int trackID;
  int startTime;
}

GenomeClass {
  Creneau* planning[NB_PAPER];
}
\end

\Before everything else function:

readPapersFile();

\end

\After everything else function:

\end

\At the beginning of each generation function:
//cout << "At the beginning of each generation function called" << endl;
\end

\At the end of each generation function:
//cout << "At the end of each generation function called" << endl;
\end

\At each generation before reduce function:
//cout << "At each generation before replacement function called" << endl;
\end

\GenomeClass::display:
\end

\GenomeClass::initialiser : // "initializer" is also accepted
  for(int i=0; i < papers.size(); i++){
    Creneau* curCrenau = (Creneau*) malloc(sizeof(Creneau));
    curCrenau->paperID = papers[i].paperID;
    curCrenau->sessionID = papers[i].sessionID;
    curCrenau->trackID = papers[i].trackID;
    if(papers[i].trackID != 15){
      curCrenau->startTime = random(0, END_CONF);
    }
    else{
      switch(papers[i].paperID){
        case 291:
          curCrenau->startTime = START_TIME_291;
          break;
        case 292:
          curCrenau->startTime = START_TIME_292;
          break;
        case 294:
          curCrenau->startTime = START_TIME_294;
          break;
        case 295:
          curCrenau->startTime = START_TIME_295;
          break;
        default:
          cout << "ERROR : plenary speach not recognized" << endl;
          exit(1);
          break;
      }
    }
    Genome.planning[i] = curCrenau;
    //cout << "paperID : " << curCrenau.paperID << " | startTime : " << curCrenau.startTime << endl;
  }

\end

\GenomeClass::crossover :
  for(size_t i=0; i<NB_PAPER;i++){
    child.planning[i]->paperID = papers[i].paperID;
    child.planning[i]->sessionID = papers[i].sessionID;
    child.planning[i]->trackID = papers[i].trackID;
    if(tossCoin(0.5)){
      child.planning[i]->startTime = parent1.planning[i]->startTime;
    }
    else{
      child.planning[i]->startTime = parent2.planning[i]->startTime;
    }
  }
\end

\GenomeClass::mutator : // Must return the number of mutations
\end

\GenomeClass::evaluator : // Returns the score as a real value
  Eval res = getEval(Genome);
  return 0;
\end

\User Makefile options:
\end

\Default run parameters :        // Please let the parameters appear in this order
  Number of generations : 30    // NB_GEN
  Time limit: 0                  // In seconds, 0 to deactivate
  Population size : 64       //POP_SIZE
  Offspring size : 64// or a xx%
  Mutation probability : 0.8       // MUT_PROB
  Crossover probability : 1      // XOVER_PROB
  Evaluator goal : maximise      // maximise
  Selection operator: Tournament 0.6
  Surviving parents: 100%        // Percentage or absolute
  Surviving offspring: 100%      // Percentage or absolute  d
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 2

  Elitism: strong                 // Weak or Strong
  Elite: 1
  Print stats: true               // Default: 1
  Generate csv stats file:true
  Generate gnuplot script:false
  Generate R script:false
  Plot stats:false                 // Default: 0

  Remote island model: false
  IP file: ip.txt                // List of IP:PORT of islands to send individuals to
  Migration probability: 0.3    // Probability of sending an individual per generation
  Server port : 2929

  Save population: false
  Start from file:false
\end
